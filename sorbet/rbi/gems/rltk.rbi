# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rltk/all/rltk.rbi
#
# rltk-3.0.1

module RLTK
end
class RLTK::ASTNode
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def children(as = nil); end
  def children=(children); end
  def copy; end
  def delete_note(key, recursive = nil); end
  def destructure(arity); end
  def dump(dest = nil, limit = nil); end
  def each(order = nil, &block); end
  def has_note?(key); end
  def initialize(*objects, &block); end
  def map!(&block); end
  def map(&block); end
  def note?(key); end
  def notes; end
  def notes=(new_notes); end
  def parent; end
  def parent=(arg0); end
  def root; end
  def self.array_members; end
  def self.check_odr(name); end
  def self.child(name, type, omit = nil); end
  def self.child_names; end
  def self.custom_order(*members); end
  def self.def_order; end
  def self.define_accessor(name, type, set_parent = nil); end
  def self.inc_children; end
  def self.inc_values; end
  def self.inherited(klass); end
  def self.install_icvars; end
  def self.member_order(val = nil); end
  def self.order(val = nil); end
  def self.value(name, type, omit = nil); end
  def self.value_names; end
  def values(as = nil); end
  def values=(values); end
  extend Filigree::AbstractClass
  extend Filigree::Destructurable
  include Filigree::Visitable
end
class RLTK::StreamPosition
  def file_name; end
  def file_name=(arg0); end
  def initialize(stream_offset = nil, line_number = nil, line_offset = nil, length = nil, file_name = nil); end
  def length; end
  def length=(arg0); end
  def line_number; end
  def line_number=(arg0); end
  def line_offset; end
  def line_offset=(arg0); end
  def start; end
  def stream_offset; end
  def stream_offset=(arg0); end
end
class RLTK::Token
  def ==(other); end
  def initialize(type, value = nil, position = nil); end
  def position; end
  def to_s; end
  def type; end
  def value; end
end
class RLTK::LexingError < StandardError
  def initialize(stream_offset, line_number, line_offset, remainder); end
  def line_number; end
  def line_offset; end
  def remainder; end
  def stream_offset; end
  def to_s; end
end
class RLTK::Lexer
  def env; end
  def initialize; end
  def lex(string, file_name = nil); end
  def lex_file(file_name); end
  def self.inherited(klass); end
  def self.install_icvars; end
  def self.lex(string, file_name = nil, env = nil); end
  def self.lex_file(file_name, env = nil); end
  def self.match_first; end
  def self.r(pattern, state = nil, flags = nil, &action); end
  def self.rule(pattern, state = nil, flags = nil, &action); end
  def self.start(state); end
  def self.start_state; end
end
class RLTK::Lexer::Environment
  def clear_flags; end
  def flags; end
  def initialize(start_state, match = nil); end
  def match; end
  def match=(arg0); end
  def pop_state; end
  def push_state(state); end
  def rule_exec(match, txt, &block); end
  def set_flag(flag); end
  def set_state(state); end
  def state; end
  def unset_flag(flag); end
end
class RLTK::Lexer::Rule
  def action; end
  def flags; end
  def initialize(pattern, action, state, flags); end
  def pattern; end
end
module RLTK::Lexers
end
class RLTK::Lexers::EBNF < RLTK::Lexer
end
class RLTK::GrammarError < StandardError
end
class RLTK::CFG
  def add_production(production); end
  def build_list_production(name, list_elements, separator = nil); end
  def build_nonempty_list_production(name, list_elements, separator = nil); end
  def build_optional_production(name, opt_symbol); end
  def callback(&callback); end
  def clause(expression); end
  def curr_lhs; end
  def curr_lhs=(arg0); end
  def first_set(sentence); end
  def first_set_prime(sym0, seen_lh_sides = nil); end
  def follow_set(sym0, seen_lh_sides = nil); end
  def get_list(name, list_elements, separator = nil); end
  def get_list_production(name, list_elements, separator = nil); end
  def get_nonempty_list(name, list_elements, separator = nil); end
  def get_nonempty_list_production(name, list_elements, separator = nil); end
  def get_optional(name, list_elements); end
  def get_optional_production(name, list_elements); end
  def initialize(&callback); end
  def list(name, list_elements, separator = nil); end
  def next_id; end
  def nonempty_list(name, list_elements, separator = nil); end
  def nonterms; end
  def optional(name, opt_symbol); end
  def production(symbol, expression = nil, &block); end
  def productions(by = nil); end
  def self.is_nonterminal?(sym); end
  def self.is_terminal?(sym); end
  def start(symbol); end
  def start_symbol; end
  def symbols; end
  def terms; end
end
class RLTK::CFG::Production
  def ==(other); end
  def copy; end
  def id; end
  def initialize(id, lhs, rhs); end
  def last_terminal; end
  def lhs; end
  def rhs; end
  def to_item; end
  def to_s(padding = nil); end
end
class RLTK::CFG::Item < RLTK::CFG::Production
  def ==(other); end
  def advance; end
  def at_end?; end
  def copy; end
  def dot; end
  def initialize(dot, *args); end
  def next_symbol; end
  def to_s(padding = nil); end
end
class RLTK::BadToken < StandardError
  def to_s; end
end
class RLTK::NotInLanguage < StandardError
  def current; end
  def initialize(seen, current, remaining); end
  def remaining; end
  def seen; end
  def to_s; end
end
class RLTK::HandledError < StandardError
  def errors; end
  def initialize(errors, result); end
  def result; end
end
class RLTK::ParserConstructionException < Exception
end
class RLTK::InternalParserException < Exception
end
class RLTK::UselessParserException < Exception
  def initialize; end
end
class RLTK::Parser
  def env; end
  def initialize; end
  def parse(tokens, opts = nil); end
  def self.add_state(state); end
  def self.build_finalize_opts(opts); end
  def self.build_list_production(symbol, list_elements, separator = nil); end
  def self.build_nonempty_list_production(symbol, list_elements, separator = nil); end
  def self.build_parse_opts(opts); end
  def self.c(expression, precedence = nil, arg_type = nil, &action); end
  def self.check_reachability(start, dest, symbols); end
  def self.check_sanity; end
  def self.clause(expression, precedence = nil, arg_type = nil, &action); end
  def self.clean; end
  def self.dat(type); end
  def self.default_arg_type(type); end
  def self.each_state; end
  def self.explain(io); end
  def self.finalize(opts = nil); end
  def self.get_io(o, mode = nil); end
  def self.grammar; end
  def self.grammar_prime; end
  def self.inform_conflict(state_id, type, sym); end
  def self.inherited(klass); end
  def self.install_icvars; end
  def self.left(*symbols); end
  def self.list(symbol, list_elements, separator = nil); end
  def self.new(*args); end
  def self.nonassoc(*symbols); end
  def self.nonempty_list(symbol, list_elements, separator = nil); end
  def self.p(symbol, expression = nil, precedence = nil, arg_type = nil, &action); end
  def self.parse(tokens, opts = nil); end
  def self.production(symbol, expression = nil, precedence = nil, arg_type = nil, &action); end
  def self.prune(do_lookahead, do_precedence); end
  def self.right(*symbols); end
  def self.start(symbol); end
  def self.token_hook(sym, &proc); end
end
class RLTK::Parser::Environment
  def error(o); end
  def errors; end
  def he; end
  def he=(arg0); end
  def initialize; end
  def pos(n); end
  def reset; end
  def set_positions(positions); end
end
class RLTK::Parser::ParseStack
  def branch(new_id); end
  def id; end
  def initialize(id, ostack = nil, sstack = nil, nstack = nil, connections = nil, labels = nil, positions = nil); end
  def output_stack; end
  def pop(n = nil); end
  def position; end
  def push(state, o, node0, position); end
  def result; end
  def state; end
  def state_stack; end
  def tree; end
end
class RLTK::Parser::State
  def <<(item); end
  def ==(other); end
  def actions; end
  def add_reduction(production); end
  def append(item); end
  def clean; end
  def close(productions); end
  def conflict_on?(sym); end
  def each; end
  def id; end
  def id=(arg0); end
  def initialize(tokens, items = nil); end
  def items; end
  def on(symbol, action); end
  def on?(symbol); end
end
class RLTK::Parser::ProdProc < Proc
  def arg_type; end
  def initialize(arg_type = nil, selections = nil); end
  def selections; end
end
class RLTK::Parser::Action
  def id; end
  def initialize(id = nil); end
end
class RLTK::Parser::Accept < RLTK::Parser::Action
  def to_s; end
end
class RLTK::Parser::GoTo < RLTK::Parser::Action
  def to_s; end
end
class RLTK::Parser::Reduce < RLTK::Parser::Action
  def initialize(production); end
  def to_s; end
end
class RLTK::Parser::Shift < RLTK::Parser::Action
  def to_s; end
end
