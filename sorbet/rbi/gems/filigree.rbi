# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/filigree/all/filigree.rbi
#
# filigree-0.4.1

class AbstractClassError < RuntimeError
  def initialize(class_name); end
end
class AbstractMethodError < RuntimeError
  def initialize(method_name, abstract_class_name); end
end
module Filigree
  def self.wrap_pattern_elements(pattern); end
end
module Filigree::AbstractClass
  def abstract_method(name); end
  def install_icvars; end
  def new(*args); end
  def self.extended(klass); end
end
module Filigree::ClassMethodsModule
  def self.included(mod); end
end
module Filigree::Configuration
  def dump(io = nil, *fields); end
  def find_option(str); end
  def handle_array_options(argv, set_opts); end
  def handle_serialized_options(overloaded, set_opts); end
  def initialize(overloaded = nil); end
  def rest; end
  def rest=(arg0); end
  def self.included(mod); end
  def serialize(io = nil, *fields); end
  include Filigree::ClassMethodsModule
end
module Filigree::Configuration::ClassMethods
  def add_option(opt); end
  def auto(name, &block); end
  def auto_blocks; end
  def bool_option(long, short = nil); end
  def default(val = nil, &block); end
  def help(str); end
  def install_icvars; end
  def option(long, short = nil, conversions: nil, &block); end
  def options_long; end
  def options_short; end
  def required(*names); end
  def required_options; end
  def self.extended(klass); end
  def string_option(long, short = nil); end
  def usage(str = nil); end
end
class Anonymous_Struct_1 < Struct
  def default; end
  def default=(_); end
  def handler; end
  def handler=(_); end
  def help; end
  def help=(_); end
  def long; end
  def long=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def short; end
  def short=(_); end
end
class Filigree::Configuration::Option < Anonymous_Struct_1
  def arity; end
  def self.to_s(options, indent = nil); end
  def to_s(max_long, max_short, indent = nil); end
end
module Filigree::Application
  def config; end
  def configuration; end
  def configuration=(arg0); end
  def initialize; end
  def self.included(klass); end
  def self.old_included(mod); end
  include Filigree::ClassMethodsModule
end
module Filigree::Application::ClassMethods
  def finalize; end
  def run; end
end
class Object < BasicObject
  def check_array_type(array, type, blame: nil, nillable: nil, strict: nil); end
  def check_type(obj, type, blame: nil, nillable: nil, strict: nil); end
  def match(*objects, &block); end
  def request_file(file, print_failure = nil); end
  def returning(value); end
end
module Filigree::TypedClass
  def self.included(mod); end
  def set_typed_ivars(vals); end
  include Filigree::ClassMethodsModule
end
module Filigree::TypedClass::ClassMethods
  def default_constructor(strict = nil); end
  def define_typed_accessor(name, nillable, strict, type, checker); end
  def typed_ivar(name, type, nillable: nil, strict: nil); end
  def typed_ivars; end
end
class CommandNotFoundError < RuntimeError
  def initialize(line); end
end
module Filigree::Commands
  def call(overloaded); end
  def self.included(mod); end
  include Filigree::ClassMethodsModule
end
module Filigree::Commands::ClassMethods
  def add_command(command_obj); end
  def command(str, &block); end
  def command_list; end
  def command_list=(arg0); end
  def commands; end
  def commands=(arg0); end
  def config(&block); end
  def get_namespace(tokens, root: nil); end
  def help(str); end
  def install_icvars; end
  def param(name, description); end
  def reify_namespace(tokens, root: nil); end
  def self.extended(klass); end
end
class Anonymous_Struct_2 < Struct
  def action; end
  def action=(_); end
  def config; end
  def config=(_); end
  def help; end
  def help=(_); end
  def name; end
  def name=(_); end
  def param_help; end
  def param_help=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Filigree::Commands::Command < Anonymous_Struct_2
end
class MatchError < RuntimeError
end
module Filigree::Destructurable
  def call(*pattern); end
end
class Filigree::MatchEnvironment
  def Bind(name); end
  def Literal(obj); end
  def find_match(objects); end
  def initialize; end
  def method_missing(name, *args); end
  def w(*pattern, &block); end
  def with(*pattern, &block); end
end
class Filigree::BasicPattern
  def <=>(other); end
  def as(binding_pattern); end
  extend Filigree::AbstractClass
  include Comparable
end
class Filigree::WildcardPattern < Filigree::BasicPattern
  def match?(_, _); end
  def self.allocate; end
  def self.new(*args); end
  def weight; end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class Filigree::SingleObjectPattern < Filigree::BasicPattern
  def initialize(pattern_elem); end
  def pattern_elem; end
  extend Filigree::AbstractClass
end
class Filigree::InstancePattern < Filigree::SingleObjectPattern
  def <=>(other); end
  def match?(object, _); end
  def weight; end
end
class Filigree::LiteralPattern < Filigree::SingleObjectPattern
  def match?(object, _); end
  def weight; end
end
class Filigree::RegexpPattern < Filigree::SingleObjectPattern
  def match?(object, env); end
  def weight; end
end
class Filigree::BindingPattern < Filigree::SingleObjectPattern
  def as(_, _); end
  def initialize(name, pattern_elem = nil); end
  def match?(object, env); end
  def pattern_elem=(arg0); end
  def weight; end
end
class Filigree::MultipleObjectPattern < Filigree::BasicPattern
  def base_compare(other); end
  def initialize(pattern); end
  def match?(objects, env); end
  def pattern; end
  extend Filigree::AbstractClass
end
class Filigree::OuterPattern < Filigree::MultipleObjectPattern
  def <=>(other); end
  def block=(arg0); end
  def call(env, objects = nil); end
  def guard; end
  def initialize(pattern, guard, block); end
  def match?(objects, env); end
end
class Filigree::DestructuringPattern < Filigree::MultipleObjectPattern
  def <=>(other); end
  def initialize(klass, pattern); end
  def klass; end
  def match?(object, env); end
  def weight; end
end
class Array
  def destructure(num_elems); end
  extend Filigree::Destructurable
end
module Filigree::Visitor
  def method_missing(name, *args); end
  def self.included(mod); end
  def visit(*objects); end
  include Filigree::ClassMethodsModule
end
module Filigree::Visitor::ClassMethods
  def Bind(name); end
  def Literal(obj); end
  def add_pattern(new_pat); end
  def inherited(klass); end
  def install_icvars(inherited_patterns = nil); end
  def method_missing(name, *args); end
  def on(*pattern, &block); end
  def patterns; end
  def self.extended(klass); end
  def strict_match(bool); end
  def strict_match?; end
end
class Filigree::TourGuide
  def initialize(*visitors); end
  def visit(*objects); end
  def visitors; end
end
module Filigree::Visitable
  def visit(visitor, method = nil); end
end
